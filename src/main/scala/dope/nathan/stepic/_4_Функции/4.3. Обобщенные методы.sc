// много повторяющегося кода с разными типами
def ifThenElseInt(cond: Boolean)
                 (t: => Int, e: => Int): Int =
  if(cond) t else e

def ifThenElseString(cond: Boolean)
                 (t: => String, e: => String): String =
  if(cond) t else e
// и т.д.

// Обобщенные методы (generics)
// методы могут иметь параметры типа - [A]
// параметры типов можно использовать для определения типов параметров
// или типов возвращаемых значений
// такие методы можно переиспользовать для разных типов

// вынести типы в качестве параметров в [] между именем и списком параметров
def ifThenElse[A](cond: Boolean, t: => A, e: => A): A =
  if (cond) t else e

// если компилятор может вывести параметры типа на основе входных параметров,
// их можно не указывать
// такие методы удобны при написании комбинаторов для функций или коллекций

//Короткая запись (???)
def combineOn[A, B](comb: (B, B) => B)
                   (f: A => B, g: B => A) : (A, A) => A =
  (x, y) => g(comb(f(x), f(y)))

val sunString = combineOn[String, Int](_ + _)(_.toInt, _.toString)
sunString("123", "32")

// Практика

// берет любую другую функцию от Int, возвращающую Int, и возвращает Int
val calc: (Int => Int) => Int = f => f(42)

// чтобы обобщить функцию, необходимо переделать ее в беспараметрический метод
// беспараметрические методы ведут себя так же, как и функции
def calc42[A]: (Int => A) => A = f => f(42)

calc42(_.toString)
calc42(i => s"number is $i")

// на больших числах
def calc42M[A]: (Int => A) => A = f => f(42000000)

calc42M(i => s"number is $i")

// "хвосто-рекурсивный комбинатор" - много функций в качестве параметров
// A - тип, который обрабатывается на каждом шаге
// B - тип, который накапливается (аккумулятор)

/*
* @param iter - регулярно превращает значение типа A в очередное значение типа A
* @param comb - регулярно комбинирует текущее значение типа B с очередным значением типа A и генерирует новое значение-аккумулятор (типа B)
* @param cond - (предикат) функция, которая берет очередное значение типа A и проверяет на необходимость остановки
*
* @param start - стартовое значение итерируемой переменной типа A
* @param init - стартовое значение аккумулятора типа B
*
* @return - когда останавливается, возвращает последнее значение аккумулятора типа B
*/

def tailRec[A, B](iter: A => A,
                  comb: (B, A) => B,
                  cond: A => Boolean)(start: A, init: B): B = {
  //  рекурсивная функция
  def go(x: A, acc: B): B =
  //  на каждом шаге проверяется выполнение условия для x
    if (cond(x))
      go(iter(x), comb(acc, x))
    else acc
  //  запуск функции
  go(start, init)
}

calc42M(n =>
  tailRec[Int,Long](_ - 1, _ + _, _ >= 0)(n, 0)
)