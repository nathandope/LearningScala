val list = List(1, 2, 3, 2)

val vector = Vector(1, 2, 3, 2)

val stream = Stream(1, 2, 3, 2)

val set = Set(1, 2, 3, 2)

val map = Map("Москва" -> 12e6, "Питер" -> 5e6)


// для последовательностей (list, vector, stream)
val phrase1 = Vector("+")

// добавить справа (только для Vector добавить в конец (справа +:) будет достаточно эффективным)
val phrase2 = phrase1 :+ "Stepik"

// добавить слева
val phrase3 = "Scala" +: phrase2

val phrase4 = Stream.empty[String]

val phrase5 = phrase4 :+ "=" :+ "Love"

// конкатенация 2х коллекция - "++"

val phrase = phrase3 ++ phrase5

phrase.mkString

// неупорядоченные коллекции (map, set)
// добавить - "+"

val cities1 = Map("Питер" -> 5e6, ("Москва" -> 12e6))

val cities2 = cities1 + ("Саратов" -> 1e6)

val cities3 = List("Волгоград" -> 1e6)

val cities = cities2 ++ cities3

// apply у последовательностей
// можно передать индекс элемента (в качестве аргумента) в переменную,
// в которой хранится последовательность
phrase(1)

// apply у ассоциативных массивов
// можно передать ключ
cities("Саратов")


// -----------------------Практика -----------------------------------------------------------------

// является ли число простым (делимсоть на все числа не больше самого числа)
// Stream - особоая версия списка с ленивым хвостом,
// который вычисляется только в момент своей необходимости,
// в т.ч. за счет этого позволяет строить бесконечные списки
def isPrime(x: Long): Boolean =
// Stream.from(2).takeWhile(_ < x) - отобрать с 2 до числа < x,
// но, т.к. не нужно проверять делители, квадрат которых > x (потому что
// для каждого такого делителя должен найтись, делить, квадрат которого < x),
// то можно брать только делители, квадрат которых не превышает (<=) x
  Stream.from(2).takeWhile(p => p * p <= x).forall(x % _ != 0)

isPrime(7)

// оптимизация ("сильно" рекурсивная)
// primes - ленивый список всех простых чисел (Long)
// #:: - ленивая конкатенация головы с оставшимся хвостом списка
// 2, 3 и шаг через 1
lazy val primes: Stream[Long] = 2L #:: Stream.iterate(3L)(_ + 2L).filter(isPrimeOptimum)

// теперь не нужно перебирать ВСЕ числа от 1 до sqrt(x),
// а достаточно перебрать ВСЕ ПРОСТЫЕ числа от 1 до sqrt(x),
// для этого можно воспользоваться числами, которые лежат в коллекции primes
def isPrimeOptimum(x: Long): Boolean = primes.takeWhile(p => p * p <= x).forall(x % _ != 0)

// force - вычислить все элементы Stream, если знаем, что он небесконечный
primes.take(1000).force // или toList