//import scala.util.Random
// http://groz.github.io/scala/intro/variance/
// https://docs.scala-lang.org/ru/tour/variances.html

// Ковариантность

// представлен обобщенный тип, имеющий один аргумент типа A
// данный обобщенный тип содержит или производит элементы типа A, =>
// ставим "+" - это означает, что будет проецироваться взаимоотношение между аргументами типа на
// взаимоотношения между коллекциями: A <:< B -> Coll[A] <:< Coll[B]
// другими словами: если тип A является подтипом типа B, тогда Coll от A является подтипом Coll от B
// также необходимо гарантировать, что параметр типа будет встречаться в определениях только в ковариантных позициях
trait Coll[+A] {
  def apply(i: Int): A
  def headOption: Option[A]
  def tail: Coll[A]
}

// Контрвариантность

// представлен обобщенный тип, имеющий один аргумент типа A
// данный обобщенный тип использует (поглащает) элементы типа A, =>
// ставим "-" - это означает, что будет проецироваться взаимоотношение между аргументами типа на
// взаимоотношения между коллекциями: A <:< B -> Printer[B] <:< Printer[A]
// другими словами: если тип A является подтипом типа B, тогда Printer от B является подтипом Printer от A
// также необходимо гарантировать, что параметр типа будет встречаться в определениях только в контрвариантных позициях,
// например:
// + def print(a: A) - как аргумент типа
// + def printList(aa: List[A]) - как аргумент типа другого ковариантного типа, который сам стоит в аргументной позиции
// + def prefixed(s: String): Printer[A] - как аргумент типа для контрвариантного типа,
// который находится в ковариантной позиции (например, в позиции аргумента)
trait Printer[-A] {
  def print(a: A): String
  def printList(aa: List[A]): String
  def prefixed(s: String): Printer[A]
}

// Вариантность

// Функция (A => B)- классический пример объединения ко- и контр- вариантностей
// функции контрвариантны по 1му параметру и ковариантны по 2му

trait Function1[-A, +R]

// [+A]
trait Coll1 [+A] {
  def apply(i: Int): A

  // передача функции в качестве аргумента, которая принимает ковариантный аргумент типа A,
  // другими словами: A присутствует в контрвариантном типе (речь про f), который сам по себе внутри аргумента =>
  // A в контр- контр- позиции, что суммарно дает ковариантную позицию для агурмента типа A
  def map[B](f: A => B): Coll[B]
}

// [-A]
trait Printer1[-A] {
  def print(a: A): String
  // обратная ситцация (???)
  def contramap[B](f: B => A): Printer[B]
}

// Род
// - тип (форма) типов

// самый простой тип родов (просто тип)
// Int, String, List[Int]: T
// Map[Int, String], Int => String : T

// обобщеные типы, т.е. типы, которые принимают в себя аргументы
// + если не передать аргумент, то сам по себе List (и т.п.) без уточненного аргумента типа
// является элементом рода T[_]
// List, Vector : T[_]
// + обобщенные типы, имеющие два аргумента типов; и они относятся к соответствующему роду
// Map, Function : T[_, _]

// более сложный род
// StateT: T[_[_], _, _]
// Hoist: T[_[_[_], _]]


// типы высших родов (Higher Kinded Types) (т.е. всех родов, кроме самого простого) используются, как правило,
// когда говорится о параметрах типов для других обобщенных типов или методов

// в данном примере заранее неизвестно, какой тип коллекции (набор) будет использоваться
// для содержания элементов типа Int
case class IntContainer[F[_]](value: F[Int])

// для типов высших родов также можно накладывать ограничения (bound)
// в данном примере используется некое промежуточное обозначение типов, а именно:
// X == (K, V)
case class Dict[K, V, T[X] <: Seq[X]](items: T[(K, V)])


//case class Named[+T](name: String, get: T)
//
//abstract class Animal(val tongue: String) {
//  val age: Int
//  def isAlive: Boolean
//}
//
//case class Dog(age: Int) extends Animal("bark") {
//  def isAlive = age < 13
//}
//
//case class Cat(age: Int, diet: String) extends Animal("meow") {
//  def isAlive = age < 15
//}
//
//object ShroedingersCat extends Cat(0, "neutrino") {
//  val rng = new Random()
//  override def isAlive = rng.nextDouble() < 0.5
//}
//
//def speak(na: Named[Animal]): Unit = {
//  val animal = na.get
//  if (animal.isAlive)
//    println(s"${na.name}: ${animal.tongue}")
//}
//
//val named = Named[Dog]("test", Dog(1))

//speak(named)